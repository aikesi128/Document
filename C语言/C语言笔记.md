[TOC]

# C语言笔记

## C语言特性

C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样

### gcc编译

​	如果是一个源文件用gcc编译:

> gcc a.c  

   如果是多个 c 代码的源码文件，编译方法如下：test1.c 与 test2.c 是两个源代码文件。

> ```
> gcc test1.c test2.c -o main.out
> ```

### 全局变量与局部变量在内存中的位置

1. 全局变量保存在内存的==全局存储区==中，占用静态的存储单元, 定义全局变量的时候, 系统会默认对其进行初始化
2. 局部变量保存在==栈==中，只有在所在函数被调用时才动态地为变量分配存储单元。 定义局部变量的时候系统不回对其进行初始化

## 数组

```
type arrayName [ arraySize ];
```

**数组名是一个指向数组中第一个元素的常量指针**

## 枚举  

定义: enum　枚举名　{枚举元素1,枚举元素2,……};

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

```
enum season {spring, summer=3, autumn, winter};
```

没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5

## 指针

要了解指针,多多少少会出现一些比较复杂的类型,所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单,一个类型里会出现很多运算符,他们也像普通的表达式一样,有优先级,其优先级和运算优先级一样,所以我总结了一下其原则:从变量名处起,根据运算符优先级结合,一步一步分析.下面让我们先从简单的类型开始慢慢分析吧



1. int *p; *//首先从P 处开始,先与\*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针*
2. int p[3]; *//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组*
3. int *p[3]; *//首先从P 处开始,先与[]结合,因为其优先级比\*高,所以P 是一个数组,然后再与\*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组*
4. int (*p)[3]; *//首先从P 处开始,先与\*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针*
5. int **p; *//首先从P 开始,先与\*结合,说是P 是一个指针,然后再与\*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针*
6. int p(int); *//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据*
7. Int (*p)(int); *//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针*
8. int *(*p(int))[3]; *//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的\*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与\*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.*

##  C 标准库

### <assert.h>

​	C 标准库的 **assert.h**头文件提供了一个名为 **assert** 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。

​	assert() 是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，**如果表达式为 FALSE (0), 程序将报告错误，	并终止执行。如果表达式不为 0，则继续执行后面的语句**。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。

### <ctype.h>

C 标准库的 **ctype.h** 头文件提供了一些函数，可用于测试和映射字符。

这些函数接受 **int** 作为参数，它的值必须是 EOF 或表示为一个无符号字符。

如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。



```
int toupper(int c);
```

如果 c 有相对应的大写字母，则该函数返回 c 的大写字母，否则 c 保持不变。返回值是一个可被隐式转换为 char 类型的 int 值。

---

```
int tolower(int c);
```

如果 c 有相对应的小写字母，则该函数返回 c 的小写字母，否则 c 保持不变。返回值是一个可被隐式转换为 char 类型的 int 值。

---

```
int isxdigit(int c);
```

检查字符是否是16进制的数字, 如果 c 是一个十六进制数字，则该函数返回非零值（true），否则返回 0（false）。

---

```
int isupper(int c);
```

如果 c 是一个大写字母，则该函数返回非零值（true），否则返回 0（false）。

---

```
int isspace(int c);
```

如果 c 是一个空白字符，则该函数返回非零值（true），否则返回 0（false）。

标准的空白字符包括：

```
' '     (0x20)    space (SPC) 空格符
'\t'    (0x09)    horizontal tab (TAB) 水平制表符    
'\n'    (0x0a)    newline (LF) 换行符
'\v'    (0x0b)    vertical tab (VT) 垂直制表符
'\f'    (0x0c)    feed (FF) 换页符
'\r'    (0x0d)    carriage return (CR) 回车符
```

---

```
int islower(int c);
```

如果 c 是一个小写字母，则该函数返回非零值（true），否则返回 0（false）。

---

```
int isdigit(int c);
```

如果 c 是一个数字，则该函数返回非零值，否则返回 0。

---

```
int isalpha(int c);
```

如果 c 是一个字母，则该函数返回非零值，否则返回 0。

---

```
int isalnum(int c);
```

如果 c 是一个数字或一个字母，则该函数返回非零值，否则返回 0。

---

### <math.h>

**math.h** 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 **double** 类型的参数，且都返回 **double** 类型的结果。

```
double sin(double x)
```

**x** -- 浮点值，代表了一个以弧度表示的角度 该函数返回 x 的正弦。

---

```
double pow(double x, double y)
```

返回 **x** 的 **y** 次幂，即 xy。

---

```
double sqrt(double x)
```

返回 **x** 的平方根。 对x开平方.	 sqrt(4.0) = 2;

---

```
double ceil(double x)
```

返回大于或等于 **x** 的最小的整数值。 向上取整.

---

```
double fabs(double x)
```

该函数返回 x 的绝对值。

----

```
double floor(double x)
```

 返回小于或等于 **x** 的最大的整数值。 向下取整.

---

```
double fmod(double x, double y)
```

返回 **x** 除以 **y** 的余数。

---

### <signal.h>

**signal.h** 头文件定义了一个变量类型 **sig_atomic_t**、两个函数调用和一些宏来处理程序执行期间报告的不同信号.

**宏 & 描述**

SIG_DFL:  默认的信号处理程序。

SIG_ERR: 表示一个错误的信号

SIG_IGN: 忽视信号



**SIG** 宏用于表示以下各种条件的信号码:

**SIGABRT**: 程序异常终止

**SIGFPE**: 算术运算出错，如除数为 0 或溢出。

**SIGILL**: 非法函数映象，如非法指令。

**SIGINT**: 中断信号，如 ctrl-C。

**SIGSEGV**: 非法访问存储器，如访问不存在的内存单元。

**SIGTERM**: 发送给本程序的终止请求信号

---

**size_t**   这是无符号整数类型，它是 **sizeof** 关键字的结果。

### <stdlib.h>

```
double atof(const char *str)
```

函数返回转换后的双精度浮点数，如果没有执行有效的转换，则返回零（0.0）。

---

```
int atoi(const char *str)
```

该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。 不会四舍五入, 直接舍弃小数点后的数据

---

```
long int atol(const char *str)
```

该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。

---

#### 内存管理

```
void *calloc(size_t nitems, size_t size)
```

返回一个指向它的指针。**malloc** 和 **calloc** 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零

---

```
void free(void *ptr)
```

指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。

---

```
void *malloc(size_t size)
```

该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL

---

```
void *realloc(void *ptr, size_t size)
```

指针指向一个要重新分配内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针。

内存块的新的大小，以字节为单位。如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针.

该函数返回一个指针 ，指向重新分配大小的内存。如果请求失败，则返回 NULL。

---

```
void abort(void)
```

中止程序执行，直接从调用的地方跳出。

---

```
int abs(int x)
```

该函数返回 x 的绝对值。 fabs(), 参数为double, 返回值为double